=head1 NAME

HTTP::State - RFC6265bis-draft-12 Cookie jar for HTTP Clients

=head1 SYNOPSIS

Importing and creating a Jar

  use HTTP::State;

  my $jar=HTTP::State->new;


Add cookies from Set_Cookies header values:

  my $request_url="http://test.example.com";
  my $string1="name1=value; Max-Age=3600; Secure; SameSite=Lax";
  my $string2="name2=value; Max-Age=3600; Secure; SameSite=Lax";

  $jar->set_cookies($request_url, $string1, $string2, ...);

  # or HTTP::CookieJar compatable API
  $jar->add($request_url, $string1);
  $jar->add($request_url, $string2);


Simple (compatible) lookup matching cookies and encode (for sending to server)

  my $request_url="http://test.example.com";
  my $string=$jar->encode_request_cookies($request_url);

  # or HTTP::CookieJar compatable API but no Same-Site processing
  $jar->cookie_header($request_url);



Secure lookup and encode (RFC6265bis) from user agent parameters:

  use HTTP::State ":constants";
  my $request_url="http://test.example.com";

  #Using the bit field to specifiy the request context information
  my $string=$jar->encode_request_cookies($request_url, FLAG_SAME_SITE | FLAG_TOP_LEVEL);

Adding cookies from a cookie structure (L<HTTP::State::Cookie>):

  # Structures and function for cookies
  use HTTP::State::Cookie;
  my $request_url="http://test.example.com";
  my $cs1=cookie_struct(name=>"value");
  my $cs2=cookie_struct(name=>"value");

  $jar->set_cookies($request_url, $cs1, $cs2, ...);

Lookup and return Key value pairs (client side)

  my @kv=$jar->get_kv_cookies($url, $referer, $action);

Lookup and return copies of cookie structures 

  my @cookie_structs=$jar->get_cookies($url, $referer, $action);



=head1 DESCRIPTION


An up to date cookie processing module, implementing a RFC6265-bis-draft based
"cookie jar" for HTTP user agents.  At the time of writing the current draft is
'12'. As it progresses this module will be updated accordingly.

A summary of cookie handling benefits from RFC6265bis include: 

=over

=item Public suffix checking

=item Prefix cookie name processing

=item Restricted upper limit of expiry dates

=item same site status

=item API or HTTP

=item safe method

=item top level navigation

=back

Default importing of the module does not import any symbols. If you intend to
use the extended RFC6265bis features directly, please import with ":constants"
parameter for bit field masks.

For explicit encoding and decoding of cookie strings (not via a cookie jar),
please see the companion L<HTTP::State::Cookie> module. This is used internally
for encoding and decoding cookies.

=head1 SAMESITE and CONTEXT

It is necessary the user agent performs additional book keeping and testing
of what is a 'same site' request, top level navigation, reloading, document etc
to fully utilise the additional functionality available in this module.

While these tests/conditions are specified in RFC6265bis, it is not in the
scope of this module and needs to be implemented in a user-agent.  The results
of such tests are represented as bit fields, which are used to guide the
store/retrieve algorithm accordingly within this module.


=head1 COMPATIBILITY

A compatibility interface matching that of  L<HTTP::CookieJar> is available to
aid in adoption of this module.

This in theory should allow user-agents like L<HTTP::Tiny> and L<Furl> for
example to benefit from performance and security improvements with limited
changes to existing code.

To work around the lack of same site / browsing context support in the
L<HTTP::CookieJar> API, the compatibility API utilises the current values of
the 'default flags' for the cookie jar. 



=head1 API

=head2 User Agent Context Flags

Flags are used to mark the intent of a request initiated by a user-agent. 

=head3 FLAG_SAME_SITE

When this flag is set, request is considered "same-site". When unset, request
is considered "cross-site".

=head3 FLAG_TYPE_HTTP

When this flag is set, request is considered "HTTP". When unset, request is
considered "non-HTTP".

=head3 FLAG_SAFE_METH

When this flag is set, request is considered "safe". When unset, request is
considered "unsafe".

=head3 FLAG_TOP_LEVEL

When this flag is set, request is considered "top level". When unset, request
is considered "not-top-level".


=head2 Storing and Retrieving

For new code these methods are preferred.


=head3 store_cookies

  $jar->store_cookies($request_uri, $flags, $string_or_struct, ...);

Takes a C<$request_url> and one or more Set-Cookie header string values B<or>
cookie_struct and inserts them into the cookie storage jar as per the 'storage
model' of RFC6265bis.

The exact processing of the cookies is subject to the C<$flags> bit field,
which is a combination of the 'context flags'. If set to C<undef> the current
default bit flags for the cookie jar will be used.

This method in intended to be called from a user-agent on receipt of a HTTP
response.

=head3 retrieve_cookies

  $jar->retrieve_cookies($request_url, $flags); 

Retrieves cookies from a jar, for the specified C<$request_url> according to
RFC6265bis 'cookie retrieval'. The cookies are encodes them into a string
suitable for use in a Cookie header in a HTTP request.

The exact processing of the cookies is subject to the C<$flags> bit field,
which is a combination of the 'context flags'. If set to C<undef> the current
default bit flags for the cookie jar will be used.

This method in intended to be called from a user-agent in generation of a HTTP
request.



=head3 dump_cookies

  $jar->dump_cookies;
  $jar->dump_cookies({persistent => 1});


Returns a list of strings encoded as Set Cookie values, but with additional
internal information.  The C<{persistent =E<gt> 1}> parameter forces only
persistent cookies to be processed, ignoring session cookies.  

B<Note:> This is only intended to generate strings which can processed later
with C<load_cookies>.


=head3 load_cookies

  $jar->load_cookies(@cookies)

Takes a list of Set-Cookie type strings written out previous with
C<dump_cookies> and injects them into the cookie jar.

B<Note:> This DOES support the internal fields generated by L<HTTP::CookieJar>
to provide an easy way to upgrade an existing cookie jar file.

Please refer to the L<HTTP::CookieJar> for further information.

=head2 Auxillary

=head3 get_cookies

  $jar->get_cookies($request_url);
  $jar->get_cookies($request_url, $flags); 

Takes the same arguments as C<retrieve_cookies> and matches the same cookies.
Returns a copied list of the matched cookie structures instead of a encoded
string.

=head3 get_kv_cookies

  $jar->get_kv_cookies($request_url);
  $jar->get_kv_cookies($request_url, $same_site_status, $type, $safe);

Takes the same arguments as C<retrieve_cookies> and matches the same cookies.
Returns a list of key value pairs, of names and values.

=head3 suffix

Wrapper around the public suffix sub. Caches results for fast subsequent
lookups. Looks up a public suffix for a given domain


=head3 second_level_domain

Like C<suffix> but returns suffix with the next level down. 
Returns the highest domain which can be set by a (sub) domain, that isn't a top
level domain/public suffix

=head2 File IO

=head3 slurp_set_cookies

Reads in previously spurted cookie strings from a file.  Tests incoming
cookies for expiry or parsing errors.  Does not process as normal set_cookie

Cookies are processed and sorted as they are read in to reduce memory requirements.


=head3 spurt_set_cookies

Writes out the contents of the database as set cookie strings, with additional
internal fields included.  Ignores any expired or session cookies



=head2 HTTP::CookieJar Compatibility Interface

These methods of the same name an intent as those found in L<HTTP::CookieJar>.
There are most certainly minor differences, but should allow a L<HTTP::State>
cookie jar to be a drop in replacement in most circumstances a
L<HTTP::CookieJar> is used. 

Support is included to B<parse> the contents of a cookie jar file created with
L<HTTP::CookieJar>, however no support is included in B<generating> a backward
compatible file. 

=head3 add

    $jar->add($url, $set_cookie_string);

Adds a cookie (as a Set_Cookie value string C<$set_cookie_string>) to the
cookie jar targeted at C<$url>. 

B<Note on SAME SITE:> It is a compatibility wrapper around C<set_cookies>
utilising the default flags for the jar, as no flags for same site support can
be supplied directly.

Please refer to the L<HTTP::CookieJar> for further information.


=head3 clear

  $jar->clear;

Removes all cookies from the jar

=head3 cookies_for

  $jar->cookies_for($url);
  $jar->cookies_for($url);

Returns a list of hash refs representing a set cookie for a target C<$url>. The
elements of each hash are named as per L<HTTP::CookieJar>. Additional elements
could also exist (ie samesite)

Please refer to the L<HTTP::CookieJar> for further information.

=head3 cookie_header

  $jar->cookie_header($url)

Retrieves any applicable cookies for the target C<$url>, and encodes into a
Cookie header string value.

B<Note on SAME SITE:> It is a compatibility wrapper around
C<encode_request_cookies> utilising the default flags for the jar, as no flags
for same site support can be supplied directly.

Please refer to the L<HTTP::CookieJar> for further information.


=head3 dump_cookies

Please refer to the L<HTTP::CookieJar> for further information.
  
=head3 load_cookies

Please refer to the L<HTTP::CookieJar> for further information.

=head3 PERFORMANCE

=head2 Algorithm

Some specific design tricks are used to improve the storage and retrieval
process compared to other cookie jars.

=over 

=item Keyed

Cookies are uniquely identified by the domain, path, name and  host only flag
(as per RFC6265bis). These are combined into a key, which make it easy to sort

=item Reversed Domain Names

The domain value (in the key and domain field) is stored in reverse, allowing
the use of C<index> to do domain matching of the key directly as  prefix instead of a suffix.


=item Cached public suffix

Public suffix lookups are cached and also stored in reverse for direct
substring comparison to domains.


=item Binary Search

Sorting and searching of the cookies is done firstly by 'second level domain'
of a request url using binary search provided by L<List::Insertion>

=item Internal 'capture'

The main retrieval subroutine is actually a anonymous sub instead of an other
method, for better argument reuse and no unneeded dynamic lookup.

=back

Cookie retrieval (100 random cookies added, 62 in jar):

                   Rate http_cookiejar     http_state  protocol_http
  http_cookiejar 58.0/s             --           -96%           -97%
  http_state     1614/s          2682%             --           -19%
  protocol_http  1987/s          3325%            23%             --

=head1 COMPARISON TO OTHER MODULES

L<Protocol::HTTP::CookieJar> is a very fast cookie jar module, also
implementing RFC6265bis, though it requires a large number of XS modules to get
going.

L<HTTP::CookieJar> is the cookie jar suggested in the L<LWP> documentation.
While it has public suffix support, it doesn't provide the additional
conditions of RFC6265bis. It is also quite slow in comparison to this module.

=head1 AUTHOR

Ruben Westerberg, E<lt>drclaw@mac.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2023 by Ruben Westerberg

Licensed under MIT

=head1 DISCLAIMER OF WARRANTIES

THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE.
